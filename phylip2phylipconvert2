import sys, argparse, re

def build_nex_phy_dict(f):
    seq_dict = {}
    reg = re.compile('^[-._\[\]|A-Za-z0-9]+\s+[-A-Za-z?]+$')
    for line in f:
        if reg.match(line):
            line = line.strip()
            fields = line.split()
            header, seq = fields[0], fields[1].replace(' ', '')
            seq_dict[header] = seq

    # Error check. if the seq_dict is empty
    # will return error message
    if seq_dict:
        return seq_dict
    else:
        sys.exit('Error: Check file, incorrect format.\n \
      Can only read in sequential phylip or nexus formats.\n \
      A character may be unsupported.\n')

def print_phylip(seqs, interleaved):
    # Get length of alignment
    count = 0
    aln_len = 0
    num_seqs = len(seqs)
    while count <= 1:
        for seq in seqs:
            aln_len = len(seqs[seq])
            count += 1

    # Prints file header
    print '{}{} {}'.format(' ', num_seqs, aln_len)

    # Statement for interleaved file
    # Phylip is the biggest pain to write out
    if interleaved:
        start = 0
        count = 0

        while start <= aln_len:
            # writes first block w/names
            if count == 0:
                for seq in sorted(seqs):
                    header = ''
                    if len(seq) <= 10:
                        header = seq
                    else:
                        header = seq[0:9]

                    sp = get_space(header)

                    print "{}{}{}".format(header, sp, seqs[seq][start:start + 70])
                    count += 1
                print ''
                start += 70

            # prints remainder of sequence w/out sequence name
            if count > 0:
                sp = '           '
                for seq in sorted(seqs):
                    print "{}{}".format(sp, seqs[seq][start:start + 70])
                print ''
                start += 70

a = build_nex_phy_dict("phylip.txt")
print_phylip(a, True)